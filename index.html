<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<script src="app.js"></script>
		<title>Meta Programming</title>
	</head>
	<body>
		<h1>Meta Programming</h1>
		<h3>Symbols</h3>
		<p>
			Symbols are a primitve value that you can use as unique object property
			identifiers. There are pre built in symbols as well as the ability to
			create your own symbols. We can create symbols to define object property
			identitfiers that dont exist yet and are unique. Becasue symbols return
			unique identifiers they are useful when we need to define properties on an
			object that we dont want people to have access to and overrirde
			essentially making them private. We can access built in symbols by
			defining the Symbol object and then with the dot notation accessing the
			symbol we want to use e.g. Symbol.toStringTag, Symbol.iterator. We create
			a symbol by defining a variable and then calling the 'Symbol()' method.
			The Symbol method can also take an argument to act as a debugging
			reference/identifier however this identifier has no meaning/relevance in
			the actual code of the application.
		</p>
		<h3>Iterators</h3>
		<p>
			An iterator is an object that has a 'next' method which then in turn
			returns a result of a certain structure. We can turn any object into an
			iterator by definining a next method named exactly 'next'. This 'next'
			method should return an object containing a 'value' property and a 'done'
			property which signals via a boolean whether there are more values to
			iterate over or not. This allows us to create a loopable object where we
			can loop/iterate over properties of an object. Creating custom looping
			logic like this can be useful for example when you only want to loop over
			values of one specific object property rather than using a for in or for
			of loop that loops over all object properties.
		</p>
		<h3>Iterators with for of loops</h3>
		<p>
			Whilst the next method turns objects into iterators they are stil not
			iterable via for loops. To make objects iterable over loops the object
			needs to have the 'iterator' symbol. By combining the 'iterator' symbol
			and an iterator object with the 'next' method inside we allow an object to
			be looped over with traditional for of loops.
		</p>
		<h3>Generators</h3>
		<p>
			Rather than having to manually create this new 'iterator' object with the
			'next' and 'done' we can use generators. A generator builds us an iterator
			object with the 'done' value and 'next' method. A generator is a special
			type of JavaScript function which generates iterator objects for you.
			Generator functions also have a 'yield' keyword which allows us to define
			the return value of the 'next' method it has when it builds the iterator
			object. The 'yield' keyword acts as a pause in execution of the generatorn
			function where behind the scenes it is just caling the next function on
			the iterator object it generated to iterate over the next property/value.
			Because generator functions create an iterable object to use them
			effectively we must call them as a variable declaration e.g. const
			myGenerator = generator() othwerise calling the function with 'next'
			everytime will return us the same value as it is creating another new
			iterable object every time. We can combine the iterator symbol with a
			generator function to make a for loop iterable object where the handling
			of when 'done' is true is handled by the for of loop. You create a
			generator function by defining a function with the '*' appended e.g.
			function* myGenerator.
		</p>
		<h3>Reflect API</h3>
		<p>
			The Reflect API allows us to control objects. It groups together static
			methods allowing us to work with objects on a meta level. We have methods
			in this API to define properties and their configuurations, set
			prototypes, deleting properties and much more. A lot of these object
			configuration methods may seem familiar as we have many of them also
			available in the gloabl 'Object'. The main difference here between the
			global 'Object' and the Reflect API is that the Reflect API offers better
			error messaging and error resolutions and also that all methods you would
			need to work with objects is all bundled together in the Reflect API
			offering more available functionality then the global 'Object' e.g.
			deleteProperty method is not available on global 'Object'.
		</p>
	</body>
</html>
